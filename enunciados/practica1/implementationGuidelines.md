# Práctica 1 - Lemmings: Guía de implementación

The purpose of this document is to help you implement Assignment 1. You are not obliged to use it.

## Structure

You have been given a template with the following packages and files.

+ `tp1`
    - _`Main`_
+ `tp1.view`
	- _`ConsoleColorsAnsiCodes`_
	- _`ConsoleColorsView`_
	- _`ConsoleView`_
	- _`GameView`_
	- `Messages`
+ `tp1.control`
    - `Controller`
+ `tp1.utils`
    - _`MyStringUtils`_
+ `tp1.logic`
    - `GameObjectContainer`
	- `Direction`
	- `Position`
+ `tp1.logic.gameobjects`
    - `Lemming`

As you can see, inside each package are various files. The files whose names appear in italics are completely implemented and you should not change their code. The other files are only partially implemented and you can (and must) add more methods and attributes to the classes they contain. You may also create other classes and/or packages, if you wish.

The code is organised (more or less) according to the very well-known _Model-View-Controller_ (MVC) design pattern.

+ The **View** corresponds to the `view` package, which contains the classes responsible for displaying the game. In this assignment, there is only one view: a text-based view of the state of the game generated by the `GameView` class, which is then displayed on the console.

+ The **Controller** corresponds to the `control` package, which contains the classes responsible for the evolution of the game: while the game has not finished it prompts the user to enter a command, executes the command by calling a method of the game and then refreshes the view. Our controller is very simple, being limited to reading commands typed by the user on the console rather than, for example, reading keyboard strokes or other alternatives. Note that the controller should know nothing about the logic of the game (to the extent that it should be easy to adapt a given controller to different similar games).

+ The **Model** corresponds `logic` package, where you will find the logic of the game, that is, the rules of the game and the handling of the game objects. The main class in this package `Game`. The object of this class performs a task when it receives an invocation from the controller which has, in turn, received a command from the user. Among the commands of the game are orders to reset the game (`reset`) and to do nothing (`none`). In the model, everything to do with the game itself is implemented: number of cycles, number of lemmings, whether the game has finished or not, if the the lemmings have won (i.e. the player has won), etc.

Once we have seen the structure of the solution, we ask...

| **Where to start?** |
| :---: |


## Division into tasks

The best way to approach large projects is to define small milestones in order to divide the project into executable mini-projects so that each mini-project extends the previous one. It is convenient to divide each mini-project into small steps whose functionality can be tested. Along these lines, we suggest the following mini-projects, each with several steps:

### [A] Show a board with various lemmings
	
1. If the template doesn't compile, add the minimum amount of code needed to make it compile. For example, if an unimplemented method must return an object, for the moment, place the instruction `return null` in the method body and then execute (the compiler will help you).

2. Display an empty board, for which it may be necessary to change the value returned by some method(s).

3. Now add several lemmings (objects of the class `Lemming`) both in different cells and in the same cell, and familiarise yourself with how they are represented.

4. Create and display `Wall` objects.

5. Implement the game cycle and the exit command.

6. Review small details (number of cycles, number of lemmings,...) that you may not yet have implemented and add the rest of the commands.

|***¡Que todo funcione correctamente!***|
| :---: |

### [B] Basic walker

1. Edit the `move` method of the `Lemming` class to make the lemmings move without falling and change direction when they reach the edge of the board. This is more easily done by ignoring the rest of the world and by using a single lemming.
        
2. Make the lemmings fall if there is no solid object beneath them.
 
3. Make the lemmings die if they fall off the board.

4. Now implement the behaviour of the lemmings if they fall onto something solid: if the fall was of 3 or more positions, they die, otherwise, they take a step.

### [C] Exit door

1. Add the `ExitDoor` class.

2. Implement the behaviour of a walking lemming when it is located on the same cell as the exit door: it leaves the game and the number of successful exits increases.

### [D] The `WalkerRole` class

1. Create the package `tp1.logic.lemmingRoles` and add the class `WalkerRole` to it.
 
2. Implement its tasks by moving part of the lemming code to this class.

### [E] Create various worlds
   
1. Add various worlds. Try to cover all the different cases in order to check all the functionality. 

|***Congratulations! It looks like you've finished!***|
| :---: |
| Execute the tests that we have given you. |
